# Lara's Personal Training Platform - Development Roadmap

## Architectural Overview

This project showcases a professional, decoupled backend architecture designed for maintainability, testability, and flexibility. Key patterns and principles employed include:

-   **Clean (Ports & Adapters) Architecture:** The core application logic is completely isolated from external concerns like frameworks and databases.
-   **Framework-Agnostic Web Layer:** The application is not tied to a single web framework. It uses a generic `HttpServer` interface with interchangeable adapters for both **Fastify** (recommended for performance) and **Express.js**.
-   **Dependency Injection (IoC):** Dependencies are managed by the **InversifyJS** IoC container, promoting modularity and dramatically simplifying testing.
-   **Schema-Based Validation:** All API input is rigorously validated using **Zod** schemas, ensuring data integrity and security at the application's entry point.
-   **Production-Ready Features:** The architecture includes a centralized `ConfigService`, framework-level request logging, a `/health` check endpoint for monitoring, and global error handlers for resilient and consistent error responses.

---

## Phase 1: Foundation & Core Architecture (The Path Out of Paralysis)

This phase is critical for building a professional, maintainable, and testable application. The detailed steps below are a guide to implementing this foundational architecture.

---

- [ ] **Step 1: Solidify Data Layer & Code Quality**
    - [ ] **A. TDD:** Finish implementing all methods in `DynamoDbUserRepo` (e.g., `update`, `getById`).
    - [ ] Create a separate suite of **integration tests** for the `DynamoDbUserRepo` that connect to the local Dockerized DynamoDB.
    - [ ] Ensure existing use case **unit tests** continue to use the fast `InMemory` repositories.
    - [ ] **B. Code Quality:** Integrate `ESLint` for linting and `Prettier` for code formatting to ensure a professional and consistent codebase.

- [ ] **Step 2: Decouple Web Framework (The Port & Adapter Pattern)**

    > ### HOW-TO GUIDE: Implementing the Port & Adapter
    >
    > **STEP 2.1: Define the `HttpServer` Interface (The Port)**
    > **HOW:**
    > - Create a file named `HttpServer.ts`.
    > - Inside, define generic interfaces: `HttpRequest`, `HttpResponse`, `Controller`, `Middleware`, and the main `HttpServer` interface with `on()` and `listen()` methods.
    > **WHY:** This is the most important step. It defines the "contract" for your web layer. It decouples your application's core logic from any specific web framework, which is the primary goal of the Ports and Adapters (Hexagonal) architecture.
    >
    > **STEP 2.2: Create the `FastifyAdapter` (The First Adapter)**
    > **HOW:**
    > - Create `FastifyAdapter.ts` with a class that `implements HttpServer`.
    > - This class will use the `fastify` library internally.
    > - Its main job is to act as a "bridge," translating Fastify's native `request` and `reply` objects into your generic `HttpRequest` and `HttpResponse` objects.
    > **WHY:** This class isolates all framework-specific code. Your application doesn't know about Fastify; it only knows about the `HttpServer` interface. The adapter handles the translation.

- [ ] **Step 3: Implement IoC Container (Dependency Injection)**

    > ### HOW-TO GUIDE: Implementing Dependency Injection
    >
    > **STEP 3.1: Decouple Controllers & Introduce DI**
    > **HOW:**
    > - Create `user.controller.ts`. Define a `UserControllers` class that takes use cases (e.g., `FindAllUsers`) as dependencies in its constructor.
    > - Introduce a DI container library like `InversifyJS`.
    > - Create `types.ts` to define unique `Symbol` identifiers for each dependency.
    > - Add `@injectable()` decorators to your classes and `@inject(TYPES.SomeType)` in the constructors to declare dependencies.
    > **WHY:** This is Inversion of Control. Instead of classes creating their own dependencies, they receive them from an external source (the container). This makes your classes incredibly easy to unit test by injecting "mock" dependencies.
    >
    > **STEP 3.2: Create the DI Container and Composition Root**
    > **HOW:**
    > - Create `inversify.config.ts`. Here, you will create the container and define all the "bindings" that map your interfaces (e.g., `HttpServer`) to concrete implementations (e.g., `FastifyAdapter`).
    > - Your `main.ts` file becomes the "Composition Root." It should be very simple: import `reflect-metadata`, import the container, get the `HttpServer` instance from it, and call `.listen()`.
    > **WHY:** This centralizes your application's "wiring." The main entry point's only job is to kick off the process, making the application easy to start and understand at a high level.

- [ ] **Step 4: Implement Foundational Services & Security**

    > ### HOW-TO GUIDE: Implementing Production-Ready Services
    >
    > **STEP 4.1: Centralized Configuration**
    > **HOW:** Create an injectable `ConfigService` (`config.service.ts`) that reads from `process.env` in one place and provide clean getters. Bind it in the DI container.
    > **WHY:** Prevents `process.env` calls from being scattered all over your codebase, making configuration explicit, manageable, and testable.
    >
    > **STEP 4.2: Input Validation Middleware**
    > **HOW:** Create `validation.middleware.ts`. Use a schema-based library like `Zod` to define the shape of your request data. The middleware function uses this schema to parse the request body. Update your adapters to execute this middleware.
    > **WHY:** Creates a reusable, declarative, and robust way to validate incoming data, keeping validation logic decoupled from controllers.
    >
    > **STEP 4.3: Health Check Endpoint**
    > **HOW:** Create a simple `health.controller.ts`. Wire it up in the DI container and add a `/health` route in your adapters.
    > **WHY:** A standard requirement for any production service for automated monitoring.
    >
    > **STEP 4.4: Global Error Handling**
    > **HOW:** In each adapter, implement the framework's native global error handler (`app.setErrorHandler` in Fastify, or an `(err, req, res, next)` middleware in Express). This handler will catch all unexpected errors.
    > **WHY:** Makes your application resilient, prevents crashes, and ensures users always receive a consistent, formatted error response.
    >
    > **STEP 4.5: Framework-Level Logging**
    > **HOW:** In each adapter's constructor, add a request logging middleware like `morgan`. Use `app.use(morgan('dev'))` for Express and `app.register(morgan, ...)` for Fastify.
    > **WHY:** Provides essential visibility into incoming requests for debugging and monitoring.

- [ ] **Step 5: Prove the Abstraction**

    > ### HOW-TO GUIDE: Proving the Architecture Works
    >
    > **STEP 5.1: Create the `ExpressAdapter`**
    > **HOW:** Create `ExpressAdapter.ts` and implement the same `HttpServer` interface, but using Express.js internally.
    > **WHY:** This is the final payoff. To switch your entire application from Fastify to Express, you now only need to change one line in `inversify.config.ts`. This demonstrates a truly professional and flexible system.

- [ ] **Step 6: Implement Core User Features & Security**
    - [ ] Create the `UserLogin` and `RefreshToken` use cases.
    - [ ] Implement JWT-based authentication middleware to protect routes.
    - [ ] **Security:** Implement rate limiting on authentication and other sensitive endpoints to prevent abuse.

- [ ] **Step 7: Enhance Observability and Documentation**
    - [ ] **API Documentation:** Integrate Swagger or a similar tool to automatically generate API documentation.
    - [ ] **Tracing:** Implement distributed tracing using OpenTelemetry (can be deferred if needed).

## Phase 2: Admin & User Functionality (Backend)

- [ ] **1. Admin Dashboard:**
    - [ ] Create a `GetAllClients` use case.
    - [ ] Create a `GetClientById` use case.
    - [ ] Create a `CreateTrainingSession` use case for a specific client.
    - [ ] Create an `UpdateTrainingSession` use case.
    - [ ] Create a `DeleteTrainingSession` use case.
    - [ ] Implement role-based access control (RBAC) to protect admin routes.

- [ ] **2. Client Dashboard:**
    - [ ] Create a `GetMyProfile` use case.
    - [ ] Create a `GetMyTrainingSessions` use case.
    - [ ] Create a `GetMyActivePlan` use case.
    - [ ] Create a `GetMyPastPlans` use case.
    - [ ] Create a `SubmitParq` use case.
    - [ ] Create an `UpdateClientPersonalInfo` use case.

## Phase 3: Video Content (Backend)

- [ ] **1. Video Upload & Processing:**
    - [ ] Create a `GeneratePresignedUrl` use case for secure video uploads to S3.
    - [ ] Implement a Lambda function to process uploaded videos (e.g., transcode to different resolutions).
    - [ ] Create a `SaveVideoMetadata` use case to save video information to DynamoDB.

- [ ] **2. Video Streaming:**
    - [ ] Create a `GetVideoStream` use case that returns a streaming URL (e.g., from CloudFront).
    - [ ] Implement a `GetAllVideosByCategory` use case.
    - [ ] Implement a `SearchVideos` use case.

## Phase 4: Payments & Subscriptions (Backend)

- [ ] **1. Payment Gateway Integration:**
    - [ ] Choose and integrate a payment gateway (e.g., Stripe or Paddle).
    - [ ] Create a `CreateCheckoutSession` use case.
    - [ ] Implement a webhook to handle successful payments and create user subscriptions.

- [ ] **2. Subscription Management:**
    - [ ] Create a `CancelSubscription` use case.
    - [ ] Create a `GetMySubscription` use case.
    - [ ] Implement a mechanism to check for active subscriptions and restrict access to content.

## Phase 5: Frontend Development

- [ ] **1. Landing Page:**
    - [ ] Create the main landing page showing available plans.
    - [ ] Integrate the payment gateway to handle plan purchases.

- [ ] **2. User Authentication:**
    - [ ] Create the user registration and login pages.
    - [ ] Implement the PARQ form for new users.

- [ ] **3. Client Dashboard:**
    - [ ] Create the main dashboard with the video carousel.
    - [ ] Implement the profile page showing training sessions and plan details.

- [ ] **4. Admin Dashboard:**
    - [ ] Create the admin dashboard to manage clients and training sessions.

## Phase 6: Production Readiness & CI/CD

- [ ] **1. Containerization:**
    - [ ] Create a `Dockerfile` for the frontend application.
    - [ ] Update the `docker-compose.yaml` to include the frontend service.

- [ ] **2. CI/CD Pipeline:**
    - [ ] Set up a CI/CD pipeline (e.g., using GitHub Actions) to automatically build, test, and deploy the application.
    - [ ] Deploy the backend and frontend to a cloud provider (e.g., AWS ECS or Vercel).

- [ ] **3. Production Operations:**
    - [ ] **Secrets Management:** Plan for production secrets management (e.g., AWS Secrets Manager) instead of .env files.
    - [ ] **Graceful Shutdown:** Implement graceful shutdown logic in the server to handle deployments smoothly.
    - [ ] **Monitoring & Alerting:** Set up monitoring dashboards (e.g., using CloudWatch or Grafana) to track application performance and health.
    - [ ] Configure alerts to notify you of any issues.

## Phase 7: Backend Processes (No direct routes)

- [ ] **1. Plan Management:**
    - [ ] Create an `ExpireUserPlan` use case to move expired plans to the past plans list.
    - [ ] Set up a scheduled job to run the `ExpireUserPlan` use case daily.

## Phase 8: Future-Proofing & Advanced Testing

- [ ] **1. API Evolution:**
    - [ ] Plan and implement an API versioning strategy (e.g., `/api/v1/...`).
- [ ] **2. Advanced Testing:**
    - [ ] Plan and implement End-to-End (E2E) tests to simulate full user journeys.


- [ ] **Step 3: Implement IoC Container (Dependency Injection)**

    > ### HOW-TO GUIDE: Implementing Dependency Injection
    >
    > **STEP 3.1: Decouple Controllers & Introduce DI**
    > **HOW:**
    > - Create `user.controller.ts`. Define a `UserControllers` class that takes use cases (e.g., `FindAllUsers`) as dependencies in its constructor.
    > - Introduce a DI container library like `InversifyJS`.
    > - Create `types.ts` to define unique `Symbol` identifiers for each dependency.
    > - Add `@injectable()` decorators to your classes and `@inject(TYPES.SomeType)` in the constructors to declare dependencies.
    > **WHY:** This is Inversion of Control. Instead of classes creating their own dependencies, they receive them from an external source (the container). This makes your classes incredibly easy to unit test by injecting "mock" dependencies.
    >
    > **STEP 3.2: Create the DI Container and Composition Root**
    > **HOW:**
    > - Create `inversify.config.ts`. Here, you will create the container and define all the "bindings" that map your interfaces (e.g., `HttpServer`) to concrete implementations (e.g., `FastifyAdapter`).
    > - Your `main.ts` file becomes the "Composition Root." It should be very simple: import `reflect-metadata`, import the container, get the `HttpServer` instance from it, and call `.listen()`.
    > **WHY:** This centralizes your application's "wiring." The main entry point's only job is to kick off the process, making the application easy to start and understand at a high level.

- [ ] **Step 4: Implement Foundational Services & Security**

    > ### HOW-TO GUIDE: Implementing Production-Ready Services
    >
    > **STEP 4.1: Centralized Configuration**
    > **HOW:** Create an injectable `ConfigService` (`config.service.ts`) that reads from `process.env` in one place and provides clean getters. Bind it in the DI container.
    > **WHY:** Prevents `process.env` calls from being scattered throughout the codebase, making configuration explicit, manageable, and testable.
    >
    > **STEP 4.2: Input Validation Middleware**
    > **HOW:** Create `validation.middleware.ts`. Use a schema-based library like `Zod` to define the shape of your request data. The middleware function uses this schema to parse the request body. Update your adapters to execute this middleware.
    > **WHY:** Creates a reusable, declarative, and robust way to validate incoming data, keeping validation logic decoupled from controllers.
    >
    > **STEP 4.3: Health Check Endpoint**
    > **HOW:** Create a simple `health.controller.ts`. Wire it up in the DI container and add a `/health` route in your adapters.
    > **WHY:** A standard requirement for any production service for automated monitoring.
    >
    > **STEP 4.4: Global Error Handling**
    > **HOW:** In each adapter, implement the framework's native global error handler (`app.setErrorHandler` in Fastify, or an `(err, req, res, next)` middleware in Express). This handler will catch all unexpected errors.
    > **WHY:** Makes your application resilient, prevents crashes, and ensures users always receive a consistent, formatted error response.
    >
    > **STEP 4.5: Framework-Level Logging**
    > **HOW:** In each adapter's constructor, add a request logging middleware like `morgan`. Use `app.use(morgan('dev'))` for Express and `app.register(morgan, ...)` for Fastify.
    > **WHY:** Provides essential visibility into incoming requests for debugging and monitoring.

- [ ] **Step 5: Prove the Abstraction**

    > ### HOW-TO GUIDE: Proving the Architecture Works
    >
    > **STEP 5.1: Create the `ExpressAdapter`**
    > **HOW:** Create `ExpressAdapter.ts` and implement the same `HttpServer` interface, but using Express.js internally.
    > **WHY:** This is the final payoff. To switch your entire application from Fastify to Express, you now only need to change one line in `inversify.config.ts`. This demonstrates a truly professional and flexible system.

- [ ] **Step 6: Implement Core User Features & Security**
    - [ ] Create the `UserLogin` and `RefreshToken` use cases.
    - [ ] Implement JWT-based authentication middleware to protect routes.
    - [ ] **Security:** Implement rate limiting on authentication and other sensitive endpoints to prevent abuse.

- [ ] **Step 7: Enhance Observability and Documentation**
    - [ ] **API Documentation:** Integrate Swagger or a similar tool to automatically generate API documentation.
    - [ ] **Tracing:** Implement distributed tracing using OpenTelemetry (can be deferred if needed).

## Phase 2: Admin & User Functionality (Backend)

- [ ] **1. Admin Dashboard:**
    - [ ] Create a `GetAllClients` use case.
    - [ ] Create a `GetClientById` use case.
    - [ ] Create a `CreateTrainingSession` use case for a specific client.
    - [ ] Create an `UpdateTrainingSession` use case.
    - [ ] Create a `DeleteTrainingSession` use case.
    - [ ] Implement role-based access control (RBAC) to protect admin routes.

- [ ] **2. Client Dashboard:**
    - [ ] Create a `GetMyProfile` use case.
    - [ ] Create a `GetMyTrainingSessions` use case.
    - [ ] Create a `GetMyActivePlan` use case.
    - [ ] Create a `GetMyPastPlans` use case.
    - [ ] Create a `SubmitParq` use case.
    - [ ] Create an `UpdateClientPersonalInfo` use case.

## Phase 3: Video Content (Backend)

- [ ] **1. Video Upload & Processing:**
    - [ ] Create a `GeneratePresignedUrl` use case for secure video uploads to S3.
    - [ ] Implement a Lambda function to process uploaded videos (e.g., transcode to different resolutions).
    - [ ] Create a `SaveVideoMetadata` use case to save video information to DynamoDB.

- [ ] **2. Video Streaming:**
    - [ ] Create a `GetVideoStream` use case that returns a streaming URL (e.g., from CloudFront).
    - [ ] Implement a `GetAllVideosByCategory` use case.
    - [ ] Implement a `SearchVideos` use case.

## Phase 4: Payments & Subscriptions (Backend)

- [ ] **1. Payment Gateway Integration:**
    - [ ] Choose and integrate a payment gateway (e.g., Stripe or Paddle).
    - [ ] Create a `CreateCheckoutSession` use case.
    - [ ] Implement a webhook to handle successful payments and create user subscriptions.

- [ ] **2. Subscription Management:**
    - [ ] Create a `CancelSubscription` use case.
    - [ ] Create a `GetMySubscription` use case.
    - [ ] Implement a mechanism to check for active subscriptions and restrict access to content.

## Phase 5: Frontend Development

- [ ] **1. Landing Page:**
    - [ ] Create the main landing page showing available plans.
    - [ ] Integrate the payment gateway to handle plan purchases.

- [ ] **2. User Authentication:**
    - [ ] Create the user registration and login pages.
    - [ ] Implement the PARQ form for new users.

- [ ] **3. Client Dashboard:**
    - [ ] Create the main dashboard with the video carousel.
    - [ ] Implement the profile page showing training sessions and plan details.

- [ ] **4. Admin Dashboard:**
    - [ ] Create the admin dashboard to manage clients and training sessions.

## Phase 6: Production Readiness & CI/CD

- [ ] **1. Containerization:**
    - [ ] Create a `Dockerfile` for the frontend application.
    - [ ] Update the `docker-compose.yaml` to include the frontend service.

- [ ] **2. CI/CD Pipeline:**
    - [ ] Set up a CI/CD pipeline (e.g., using GitHub Actions) to automatically build, test, and deploy the application.
    - [ ] Deploy the backend and frontend to a cloud provider (e.g., AWS ECS or Vercel).

- [ ] **3. Production Operations:**
    - [ ] **Secrets Management:** Plan for production secrets management (e.g., AWS Secrets Manager) instead of .env files.
    - [ ] **Graceful Shutdown:** Implement graceful shutdown logic in the server to handle deployments smoothly.
    - [ ] **Monitoring & Alerting:** Set up monitoring dashboards (e.g., using CloudWatch or Grafana) to track application performance and health.
    - [ ] Configure alerts to notify you of any issues.

## Phase 7: Backend Processes (No direct routes)

- [ ] **1. Plan Management:**
    - [ ] Create an `ExpireUserPlan` use case to move expired plans to the past plans list.
    - [ ] Set up a scheduled job to run the `ExpireUserPlan` use case daily.

## Phase 8: Future-Proofing & Advanced Testing

- [ ] **1. API Evolution:**
    - [ ] Plan and implement an API versioning strategy (e.g., `/api/v1/...`).
- [ ] **2. Advanced Testing:**
    - [ ] Plan and implement End-to-End (E2E) tests to simulate full user journeys.
